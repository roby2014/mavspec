use crate::types::{DialectId, DialectVersion, MessageId};
use crate::{IntoPayload, MessageInfo, MessageSpec, Payload, SpecError};

/// Interface for autogenerated or custom MAVLink dialect specification.
pub trait Dialect: MessageSpec + IntoPayload + Sized + Sync + Send {
    /// Dialect name as it appears in XML definition.
    fn name() -> &'static str;

    /// Returns `dialect` identifier as specified in MAVLink [XML definitions](https://mavlink.io/en/guide/xml_schema.html).
    fn dialect() -> Option<DialectId>;

    /// Minor dialect `version` as specified in MAVLink [XML definitions](https://mavlink.io/en/guide/xml_schema.html).
    ///
    /// Corresponds to [`uint8_t_mavlink_version`](https://mavlink.io/en/messages/common.html#HEARTBEAT).
    ///
    /// Dialect version appears in some messages like [HEARTBEAT](https://mavlink.io/en/messages/common.html#HEARTBEAT). In
    /// such cases it is usually not directly set by user.
    fn version() -> Option<DialectVersion>;

    /// Message specification by `id`.
    ///
    /// Clients may access this method to retrieve message specification prior to decoding it from
    /// payload.
    ///
    /// # Errors
    ///
    /// Returns [`SpecError::NotInDialect`] if message with specified ID is not supported.
    fn message_info(id: MessageId) -> Result<&'static dyn MessageSpec, SpecError>;

    /// Decode [`Message`](Self::Message) from [`Payload`].
    fn decode(payload: &Payload) -> Result<Self, SpecError>;

    /// Dialect specification.
    fn spec() -> DialectSpec;
}

/// Dialect specification.
#[derive(Clone, Debug)]
pub struct DialectSpec {
    name: &'static str,
    dialect: Option<DialectId>,
    version: Option<DialectVersion>,
    messages_info: &'static [MessageInfo],
}

impl DialectSpec {
    /// Creates dialect specification.
    pub const fn new(
        name: &'static str,
        dialect: Option<DialectId>,
        version: Option<DialectVersion>,
        messages_info: &'static [MessageInfo],
    ) -> Self {
        Self {
            name,
            dialect,
            version,
            messages_info,
        }
    }

    /// Dialect name as it appears in XML definition.
    pub fn name(&self) -> &'static str {
        self.name
    }

    /// Returns `dialect` identifier as specified in MAVLink [XML definitions](https://mavlink.io/en/guide/xml_schema.html).
    pub fn dialect(&self) -> Option<DialectId> {
        self.dialect
    }

    /// Minor dialect `version` as specified in MAVLink [XML definitions](https://mavlink.io/en/guide/xml_schema.html).
    ///
    /// Corresponds to [`uint8_t_mavlink_version`](https://mavlink.io/en/messages/common.html#HEARTBEAT).
    ///
    /// Dialect version appears in some messages like [HEARTBEAT](https://mavlink.io/en/messages/common.html#HEARTBEAT). In
    /// such cases it is usually not directly set by user.
    pub fn version(&self) -> Option<DialectVersion> {
        self.version
    }

    /// Message specification by `id`.
    ///
    /// Clients may access this method to retrieve message specification prior to decoding it from
    /// payload.
    ///
    /// # Errors
    ///
    /// Returns [`SpecError::NotInDialect`] if message with specified ID is not supported.
    pub fn message_info(&self, id: MessageId) -> Result<&MessageInfo, SpecError> {
        for info in self.messages_info {
            if info.id() == id {
                return Ok(info);
            }
        }
        Err(SpecError::NotInDialect(id))
    }
}
