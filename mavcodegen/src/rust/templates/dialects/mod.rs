use crate::rust::RustGeneratorParams;
use mavspec::protocol::Dialect;
use serde::Serialize;

pub mod enums;
pub mod messages;

/// Dialects module root template.
///
/// Input: [`mavspec::protocol::Protocol`].
pub const DIALECTS_ROOT_MODULE: &str = r#"//! # Autogenerated MAVLink dialects
//!
//! > *Generated by [`MAVCodeGen`](https://gitlab.com/mavka/libs/mavcodegen)*
//!
//! Each dialect is packaged into a module with corresponding (`snake_cased`) name.
#![warn(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]

{{#each dialects}}
/// `{{name}}` dialect.
pub mod {{to-dialect-name name}};

{{/each}}
"#;

/// Input for [`DIALECT_MODULE`].
#[derive(Clone, Debug, Serialize)]
pub struct DialectModuleSpec<'a> {
    pub dialect: &'a Dialect,
    pub params: &'a RustGeneratorParams,
}

/// Dialect module root template.
///
/// Input: [`DialectModuleSpec`].
pub const DIALECT_MODULE: &str = r#"//! # MAVLink dialect `{{dialect.name}}`

use mavlib_spec::{
    IntoMavLinkPayload, MavLinkDialectSpec, MavLinkMessagePayload, MavLinkMessageSpec,
    MavLinkVersion, MessageError,
};

// MAVLink messages.
pub mod messages;
// MAVLink enums.
pub mod enums;

/// Dialect name as it appears in XML definition.
/// 
/// See [`MavLinkDialectSpec::name`].
const NAME: &str = "{{dialect.name}}";
/// [`Dialect`] specification.
///
/// See: [`MavLinkDialectSpec`].
const SPEC: Dialect = Dialect {};

/// Dialect specification.
///
/// This struct can'be instantiated directly. The constant (and the only) instance is accessable
/// through [`spec`] function.  
#[derive(Copy, Clone, Debug, Default)]
struct Dialect;

impl Dialect {
    /// Dialect name as it appears in XML definition.
    /// 
    /// See [`MavLinkDialectSpec::name`].
    #[inline]
    pub fn name() -> &'static str {
        NAME
    }

    /// Message specification by `id`.
    /// 
    /// See [`MavLinkDialectSpec::message_info`].
    #[inline]
    pub fn message_info(id: u32) -> Result<&'static dyn MavLinkMessageSpec, MessageError> {
        message_info(id)
    }
}

impl MavLinkDialectSpec for Dialect {
    /// Message specification by `id`.
    ///
    /// See [`MavLinkDialectSpec::name`].
    #[inline]
    fn name(&self) -> &str {
        Self::name()
    }

    /// Message specification by `id`.
    /// 
    /// See [`MavLinkDialectSpec::message_info`].
    #[inline]
    fn message_info(&self, id: u32) -> Result<&dyn MavLinkMessageSpec, MessageError> {
        Self::message_info(id)
    }
}

/// Enum containing all messages within `{{dialect.name}}` dialect.
#[derive(Clone, Debug)]
// {{#if params.serde}}#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]{{/if}}
pub enum Message {
{{#each dialect.messages}}
    /// MAVLink message `{{name}}`.
    {{to-messages-enum-entry-name name}}(messages::{{to-message-struct-name name}}),
{{/each}}
}

impl TryFrom<&MavLinkMessagePayload> for Message {
    type Error = MessageError;

    /// Decodes message from MAVLink payload.
    fn try_from(value: &MavLinkMessagePayload) -> Result<Self, Self::Error> {
        Self::decode(value)
    }
}

impl IntoMavLinkPayload for Message {
    /// Encodes message into MAVLink payload.
    fn encode(
        &self,
        version: MavLinkVersion,
    ) -> Result<MavLinkMessagePayload, MessageError> {
        self.encode(version)
    }
}

impl Message {
    /// Decodes message from MAVLink payload.
    pub fn decode(
        payload: &MavLinkMessagePayload,
    ) -> Result<Self, MessageError> {
        decode(payload)
    }

    /// Encodes message to MAVLink payload.
    pub fn encode(&self, version: MavLinkVersion) -> Result<MavLinkMessagePayload, MessageError> {
        encode(self, version)
    }
}

/// Dialect specification.
///
/// Returns the current dialect specification as [`MavLinkDialectSpec`] trait object.
#[inline]
pub const fn spec() -> &'static dyn MavLinkDialectSpec {
    &SPEC
}

/// Retrieve message specification by its `id`.
/// 
/// See [`MavLinkDialectSpec::message_info`].
pub fn message_info(id: u32) -> Result<&'static dyn MavLinkMessageSpec, MessageError> {
    Ok(match id {
{{#each dialect.messages}}
        {{id}} => &messages::{{to-message-mod-name name}}::MESSAGE_INFO,
{{/each}}
        _ => return Err(MessageError::UnsupportedMessageId(id)),
    })
}

/// Decodes message from [`MavLinkMessagePayload`].
pub fn decode(payload: &MavLinkMessagePayload) -> Result<Message, MessageError> {
    Ok(match payload.id() {
{{#each dialect.messages}}
            messages::{{to-message-mod-name name}}::MESSAGE_ID => Message::{{to-messages-enum-entry-name name}}(messages::{{to-message-struct-name name}}::try_from(payload)?),
{{/each}}
        id => return Err(MessageError::UnsupportedMessageId(id)),
    })
}

/// Encodes message to [`MavLinkMessagePayload`].
pub fn encode(msg: &Message, version: MavLinkVersion) -> Result<MavLinkMessagePayload, MessageError> {
    Ok(match msg {
{{#each dialect.messages}}
        Message::{{to-messages-enum-entry-name name}}(message) => {message.encode(version)?}
{{/each}}
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn retrieve_message_info() {
        for id in [
{{#each dialect.messages}}
            {{id}},
{{/each}}
        ] {
            let msg_info = spec().message_info(id);
            assert!(msg_info.is_ok());
            assert_eq!(msg_info.unwrap().id(), id);
        }
    }
}
"#;
