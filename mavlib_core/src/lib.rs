//! # MAVLib Core
//!
//! Low-level [MAVLink](https://mavlink.io/en/) library based on [MAVSpec](https://gitlab.com/mavka/libs/mavspec) and
//! [MAVCodeGen](https://gitlab.com/mavka/libs/mavcodegen).
//!
//! # Features
//!
//! This library is a building block for more sophisticated tools. It includes absolute minimum of functionality
//! required for correct communication with everything that speaks MAVLink protocol:
//!
//! * It supports both `MAVLink 1` and `MAVLink 2` protocol versions.
//! * Provides intermediate MAVLink packets decoding with [`Frame`] with only header, checksum and signature being
//!   deserialized. Which means client don't have to decode the entire message for routing and verification.
//! * Supports optional high-level message decoding by utilizing MAVLink abstractions generated by
//!   [MAVCodeGen](https://gitlab.com/mavka/libs/mavcodegen).
//! * Includes standard MAVLink dialects enabled by cargo features.
//! * Implements message verification via checksum.
//! * Includes tools for [message signing](https://mavlink.io/en/guide/message_signing.html).
//!
//! ## Extra features
//!
//! Most of the "extra" features are related to decoupling from MAVLink XML definitions parsing and code generation.
//! These tasks are performed by [MAVInspect](https://gitlab.com/mavka/libs/mavinspect) and
//! [MAVCodeGen](https://gitlab.com/mavka/libs/mavcodegen) respectively.
//!
//! * Supports custom dialects or way work with no dialect at all (for intermediate decoding).
//! * Includes support for custom payload decoders and encoders. Which means that clients are not bounded by
//!   abstractions generated by `MAVCodeGen`.
//! * Can read and write messages to anything that implements [`std::io::Read`](https://doc.rust-lang.org/std/io/trait.Read.html)
//!   and [`std::io::Write`](https://doc.rust-lang.org/std/io/trait.Write.html) traits.
//! * Compatible with `no_std` targets. For such cases the library provides simplified versions of `Read` and `Write`
//!   traits.
//! * Respects dialect inheritance. Messages defined in one dialect are not redefined upon inclusion into another
//!   dialect. This means that if you have a message `M` from dialect `A` being included by dialect `B`, it guaranteed
//!   that you can use Rust structs for message `M` with both of the dialects.  
//!
//! ## Out of scope
//!
//! There are few *stateful* features required by MAVLink protocol this library intentionally does not implements and
//! leaves for the client:
//!
//! * Sending automatic heartbeats. This is required by most of the clients which would consider nodes without heartbeat
//!   updates as inactive or invalid.
//! * Message sequencing. This requires auto-incrementing packet sequence number upon each new message sent within a
//!   particular MAVLink network.  
//! * Stateful timestamp management for message signing that ensures that messages are not sent with the same timestamp.
//!
//! # Dialects
//!
//! Standard MAVLink dialect can be enabled by the corresponding cargo features.
//!
//! * [`minimal`]((https://mavlink.io/en/messages/minimal.html)) — minimal dialect required to expose your presence to
//!   other MAVLink devices.
//! * [`standard`](https://mavlink.io/en/messages/standard.html) — a superset of `minimal` dialect which expected to be
//!   used by almost all flight stack.
//! * [`common`](https://mavlink.io/en/messages/common.html) — minimum viable dialect with most of the features, a
//!   building block for other future-rich dialects.
//! * [`ardupilotmega`](https://mavlink.io/en/messages/common.html) — feature-full dialect used by
//!   [ArduPilot](http://ardupilot.org). In most cases this dialect is the go-to choice if you want to recognize almost
//!   all MAVLink messages used by existing flight stacks.
//! * [`all`](https://mavlink.io/en/messages/all.html) — meta-dialect which includes all other standard dialects
//!   including these which were created for testing purposes. It is guaranteed that namespaces in the `all` family of
//!   dialects do not collide.

#![warn(missing_docs)]
#![deny(rustdoc::broken_intra_doc_links)]
#![cfg_attr(not(feature = "std"), no_std)]
#[cfg(feature = "alloc")]
extern crate alloc;

pub mod consts;

pub mod protocol;
#[doc(inline)]
pub use protocol::Frame;

pub mod errors;
#[doc(inline)]
pub use errors::Result;

pub mod io;
#[doc(inline)]
pub use crate::io::{Receiver, Sender};

pub mod utils;

mod mavlink {
    include!("mavlink/mod.rs");
    // include!(concat!(env!("OUT_DIR"), "/mavlink/mod.rs"));
}
pub use mavlink::dialects;
